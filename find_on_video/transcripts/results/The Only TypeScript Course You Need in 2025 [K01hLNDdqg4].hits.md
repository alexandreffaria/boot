Transcript Search (grouped by word, hits only)
Transcript: The Only TypeScript Course You Need in 2025 [K01hLNDdqg4].txt
Mode: whole-word
Highlight: [[match]]
------------------------------------------------------------------------

INDEX (hits per word):
- sucky: 1
- bad: 6
- pain: 1
- help: 19
- i don't know: 9
- don't understand: 1
- doesn't make sense: 3
- why: 32
- man: 1
- broken: 3
- bug: 5
- buggy: 1
- frustrating: 1
- annoying: 2
- mad: 4
- angry: 7
- hard: 19
- harder: 1
- hardest: 1
- difficult: 6
- confusing: 10
- lost: 1
- confused: 5
- stuck: 4
- can't: 39
- cannot: 7
- couldn't: 1
- won't: 6
- wouldn't: 1
- don't get: 5
- doesn't work: 5
- broken: 3
- problem: 24
- problems: 9
- issues: 3
- trouble: 1
- error: 120
- errors: 59
- fail: 1
- failed: 1
- failing: 1

========================================================================

WORD: "sucky"  —  1 hit
------------------------------------------------------------------------
[6:57] thinking, well, this TypeScript thing kind of seems [[sucky]]. But the really nice thing is that TypeScript is actually super super smart. So instead of you

WORD: "bad"  —  6 hits
------------------------------------------------------------------------
[15:12] [[bad]] code that we wrote, we can see everything is working just fine. And if I try to run this, we should see it's working.
[1:54:24] reason something [[bad]] got passed into this function. You'll notice an error. We didn't actually pass in the code 500.
[2:34:33] the type should be chat right here. So, I just need to change this to chat. That was just my [[bad]]. Again, not reading the
[2:55:00] around the TypeScript system. And you're most likely going to see this when you're either integrating a library that has really [[bad]] TypeScript support and
[2:55:13] let's look at the question here. Why is double assertion usually a [[bad]] idea? Because you should have used oakl. Well, we can skip that because of a potential
[3:02:47] of doing things, it's not too [[bad]]. Now, I do really quickly want to talk about what protected is in case you're unfamiliar. Protected is essentially a

WORD: "pain"  —  1 hit
------------------------------------------------------------------------
[4:22:36] go. I absolutely love Vit because of how easy it makes everything because like I said, it was really a [[pain]] having to run

WORD: "help"  —  19 hits
------------------------------------------------------------------------
[2:59] channel. And he's an incredible instructor. I'm super glad that we were able to convince him to [[help]] out with this video. Okay, now we're just about
[3:18] is just not our system. I have no way of knowing if you actually do it, but it does [[help]] us to be able to continue to
[4:27] JavaScript code, which is what this is, and we're adding in types to that code to [[help]] our code understand what
[5:37] there for when you're actually developing your code to [[help]] you figure out what different things should be, but it doesn't actually exist when you run
[10:02] lesson kind of reinforces some of them. And the big one that I really want to catch on is first of all, it'll [[help]] you catch bugs because of different type
[1:07:49] something that the TypeScript does for you in your editor to [[help]] you out, but it doesn't really change how TypeScript works. And that is how it handles extra
[1:08:57] actually going to get an error because this weapons is not required. And this is just to [[help]] out you as a developer
[1:09:30] there to [[help]] you out as a developer. For example, if you spelled speed incorrectly, you spelled it sped d instead of eede d. It would give you a
[1:54:36] never type can actually [[help]] us with that. If we scroll down here a little bit further, you can see right here, we're taking this error and we're
[1:55:24] a look at our code. You can see we have three slash commands, greet, info, and [[help]]. And we have a greet message, an info message, and a [[help]] message. And if
[1:55:30] the command is greet, we do greet. If the command is info, we do info. And of course, here we have that error. Type [[help]] is not assignable the type number
[1:55:36] because we forgot to check the never or the [[help]] type up here. So we can come in here and we can actually do a quick
[1:55:41] check for that. And that'll at least solve our problem. So we can say this will return our [[help]] message. And actually, if we run that right now,
[1:56:36] override any type information. So my command still has this specific type of [[help]], which it should. And this is really useful because right now my code
[3:25:29] I would recommend if you really get stuck with this section, just repeat this section of the video and it'll really [[help]] you understand what generics
[4:00:52] And the reason that they ask you to install it globally is to [[help]] make these tests actually run properly. So I'm going to make sure that we actually
[4:06:06] plate in your code, but can [[help]] you fix some runtime errors where you actually don't have an element in your array when you try to access it. So, what we need
[4:06:48] going to console log whatever welcome returns. There we go. That'll just [[help]] with them
[4:23:11] and so on. Wherever you get stuck, come back, re-watch that section, and hopefully with your newfound knowledge and your trial and error, it'll [[help]] you

WORD: "i don't know"  —  9 hits
------------------------------------------------------------------------
[14:16] get any errors because essentially TypeScript says this could be anything. So it maybe has a function with this name. [[I don't know]]. Now I personally
[1:47:11] one of the downsides to using a tupole instead of an object is what is this string? What is this number? What is this boolean? [[I don't know]] what these
[2:20:03] number for user type, [[I don't know]] what seven is inside my user type. But if this was a string, it would be a little
[2:31:57] string. So unknown essentially tells Typescript [[I don't know]] what this thing is and [[I don't know]] how to process it.
[2:32:19] check the type of something before you actually use it. I like to think of any as essentially turning TypeScript off while unknown just says [[I don't know]]
[3:23:51] function parameters. And you create your own custom type. [[I don't know]] what this type is. This could be a number. This could be a string. It could be a bunch
[3:23:57] of different types. [[I don't know]] what it is. I just call it a generic type. You can call it T, but you can call it literally anything you want. I can call
[3:24:09] Typescript, [[I don't know]] what this element type is. I haven't figured it out yet. But I do know anytime that I
[4:05:48] access. Essentially, if I try to access the value of an array, [[I don't know]] if that value exists or not. In TypeScript,

WORD: "don't understand"  —  1 hit
------------------------------------------------------------------------
[2:36:51] it says we [[don't understand]]. And actually, we just return that as a string, I believe. There we go. And that should solve all those different

WORD: "doesn't make sense"  —  3 hits
------------------------------------------------------------------------
[36:14] before a required parameter. That just [[doesn't make sense]]. So, if I come in here and I try to make this optional and I try to make this required, that's not
[4:00:04] particular code and actually going back a second I don't need as constant here that [[doesn't make sense]]. This is not a type this is just there's not a value in
[4:04:48] really old JavaScript project to TypeScript, maybe then it [[doesn't make sense]] cuz you're going to have so many errors immediately. But strict, if

WORD: "why"  —  32 hits
------------------------------------------------------------------------
[8:08] JavaScript almost anytime I have that choice to make. Let's talk about [[why]] it exists in the first place and then what
[8:14] exactly Typescript is because it's not your typical programming language. The big picture [[why]] is simple. JavaScript is
[9:57] for JavaScript. Now, I've already talked a little bit about [[why]] you may want to use TypeScript over JavaScript. And this
[15:36] undefined, which is [[why]] we're getting tons of different errors. And in order to fix this particular problem, we need to specifically type what these
[17:42] know [[why]] you're using TypeScript in the first place. So, the bit about being in the code versus like shown on Hover
[18:31] Okay, so now [[why]] might you want to use an inferred return type? Well, the big reason in favor of inferred or implicit
[22:34] [[why]] I pretty much always leave this just as an inferred return type. And anytime that I can infer things in Typescript, I
[24:39] asynchronous, all these different things. So that is [[why]] TypeScript actually introduced a way to type specific functions. And the way you do
[25:56] is we need to specify the variable name and the type of the variable. That's [[why]] this top one doesn't work because it doesn't have variable names. And this
[29:13] all that extra code inside of our system which is [[why]] we have these import of type. So we can explicitly say I want to
[32:47] two lowerase. So it's going to throw an error for me. So this is [[why]] this type narrowing is really important because it allows you to take something that is
[44:04] values that are literal values. That's [[why]] they call it a literal type instead of a generic type such as a string,
[53:14] which is [[why]] we're passing it in like this. And the next thing we need to do is our log source right here. So let's come in here. We'll export a type log
[1:05:35] something that you may want to watch out for, which is [[why]] I pretty much always recommend if you're creating an array and then adding data to it later, I
[1:34:52] these different typo things, which is [[why]] I love having TypeScript because at least it tells me when I make these types of typos. Now, when I submit, you
[1:41:04] Just like that. And now essentially I'm checking the lowercase version which should fix our problem. And now we have no errors. So now I want to show you [[why]]
[1:42:05] something that is only too long. So that's a little bit confusing which is [[why]] they recommend that you use the readonly property when you're working
[1:56:49] scroll down, I immediately get errors to notify me that I need to update my code to handle that brand new command that I just created, which is [[why]] this type of
[1:57:01] that properly. So, this is [[why]] I really love that never type. Now, when you combine together types that share properties, you may run into certain
[2:14:25] interfaces that for the most part I absolutely hate and is [[why]] I generally use types instead of interfaces and that
[2:15:55] quickly look at the question here. [[Why]] is type often safer than interface? Well, that's because type aliases don't merge together when you redeclare them.
[2:16:18] recommend that you use. Now I will be covering at the end of this section enums versus union types [[why]] I don't
[2:17:31] values and so on that enums are much less needed which is [[why]] they have other ways of doing enums which again I'll
[2:18:16] actually adding new JavaScript code to your compiled bundle. This is another reason [[why]] a lot of people don't like
[2:22:17] There's no two-way mapping for strings. That two-way mapping only works for numbers, which is [[why]] it's much more complicated to work with numbers versus
[2:24:37] think is the most important lesson in this entire section. And if you skipped ahead, this is where you want to come to because this is talking about [[why]] you
[2:25:26] [[why]] is that? First, unions are already part of TypeScript, and we use them for more powerful things than just enum like
[2:51:36] give me an error. So, it's a potential source of errors, which is [[why]] I generally try not to use as very often.
[2:55:13] let's look at the question here. [[Why]] is double assertion usually a bad idea? Because you should have used oakl. Well, we can skip that because of a potential
[3:22:50] about what generics are and [[why]] they're so useful, but the easiest way in my opinion to understand generics is actually just implement and use some
[3:30:32] Instead, we want to retain that type information, which is [[why]] we're using generics because it allows us to pass along that type information and just
[4:16:20] try to make sure that you're the exact same version, which is [[why]] I generally don't recommend installing TypeScript globally and instead I recommend

WORD: "man"  —  1 hit
------------------------------------------------------------------------
[16:51] to not only steal [[man]] both sides of the argument, but also weigh in with my own opinion. The argument, should you allow

WORD: "broken"  —  3 hits
------------------------------------------------------------------------
[8:44] users start sending you angry support emails telling you your site is [[broken]]. The creators of Typescript were
[18:14] actually returns this, you've potentially [[broken]] all the places where the function's called. Had you
[4:18:31] something is [[broken]] because like a library you're using is [[broken]], it needs to be updated. So, you can just throw an

WORD: "bug"  —  5 hits
------------------------------------------------------------------------
[2:03:19] unexpected merging [[bug]]. Now to be fair, there are two times when I'll use an interface over a type in real world
[2:29:55] limit is throwing a particular error for us. We just want to fix that [[bug]] using type limiting. So here we have a regular
[3:15:25] compile time [[bug]] for update user. It should accept a user object but where each property is optional. So that's super simple. We can just wrap this in a
[3:19:25] type of situation. So let's go ahead and actually do our code. We just need to fix the [[bug]] in get status message. So if we look at this map here, you can see
[3:20:37] various different types while keeping that one main type as my single source of truth. Now, if we look at our assignment, we just need to fix a [[bug]]

WORD: "buggy"  —  1 hit
------------------------------------------------------------------------
[1:38:43] [[buggy]] in this particular instance. If you mess up your types, TypeScript's not smart enough to fix that for you. So, it

WORD: "frustrating"  —  1 hit
------------------------------------------------------------------------
[2:02:01] worked properly. One of the most [[frustrating]] things in

WORD: "annoying"  —  2 hits
------------------------------------------------------------------------
[20:37] that's a little bit [[annoying]] is you notice we had to write a lot of explicit types in that last example. But in this one, we're actually going to get around
[2:04:53] TypeScript is a little bit [[annoying]] and that they actually have two ways to define types. You can use the type

WORD: "mad"  —  4 hits
------------------------------------------------------------------------
[3:42:17] sentiment string and that's a utility type that evaluates to [[mad]] or furious if t includes angry otherwise content of
[3:42:35] is true then we know that it is going to be returning [[mad]]
[3:42:40] whoops [[mad]] or furious. Make sure that I put a question mark
[3:43:50] the code inside this false section. And these are just returning types to us. So, it has a type of [[mad]] or furious and

WORD: "angry"  —  7 hits
------------------------------------------------------------------------
[8:44] users start sending you [[angry]] support emails telling you your site is broken. The creators of Typescript were
[10:48] which nobody does, these errors are going to make it into production. Then you're going to get [[angry]] emails from users, and that's definitely not what
[2:36:34] essentially do the exact same thing, but this one is for dissatisfied and [[angry]]. So I'll use [[angry]] here. and we'll use
[3:42:17] sentiment string and that's a utility type that evaluates to mad or furious if t includes [[angry]] otherwise content of
[3:42:29] equal to a specific type and if T extends an object where [[angry]]
[3:43:10] object that has an [[angry]] property set to true, we get this. Otherwise, we get this. And the way that I look at code
[3:43:39] particular shape, if it satisfies the shape, I don't care if T has other properties or anything like that. As long as it has a property [[angry]] and

WORD: "hard"  —  19 hits
------------------------------------------------------------------------
[14:48] a TypeScript codebase. It is a great way to essentially sprinkle those enies in in the particular places where maybe you have [[hard]] to write types that require
[23:38] we can just implicitly do this as well. So if I remove this type that's [[hard]]-coded onto here and I hover over log system, you can see it still has
[44:32] has one possible value, which is north. So literals are really great when you have a [[hard]]-coded set of values that
[49:44] But you also want the person using your code to be able to pass along any other metadata they want. So you have some [[hard]]-coded metadata and then they can
[49:51] just pass along whatever other metadata they want. This would be a great use case for that because you can specify some [[hard]]-coded values that say, "Hey,
[54:52] time when I'm using unions, I write my unions with just [[hard]]-coded values like this. Or if I'm using this string
[1:05:41] pretty much always recommend [[hard]]- coding what the type of that array is. Like in this case, if it was a boolean array, I would do something like this.
[1:09:15] minimum required properties you need. But if you're [[hard]]- coding what object you're passing along, that means most
[1:13:05] It's going to have a [[hard]]-coded discriminating value. So in our case, the property is kind. And if we have a multiple choice lesson, the kind is
[1:15:24] let's go up here. We'll say that the kind is going to be internal. This must be that [[hard]]-coded discriminating value.
[1:19:07] with a number, we can now actually remove this generic [[hard]]-coded type because Typescript is smart enough to
[1:24:09] Usually, you either want to have a fully [[hard]]-coded object with all the properties that are required or you want a fully dynamic object. There are very
[1:38:08] different definitions included. Now, the reason that I say that this type of code is kind of fragile and [[hard]] to work with
[1:39:06] [[hard]]-coded array of values that you add as const, it gives you essentially a tupil as the return value. And a tupil
[1:39:27] generic number, it had a [[hard]]-coded value like Kyle and a [[hard]]-coded number like 30. But in our case, we're saying
[1:57:37] And same thing with human, we have specific [[hard]]-coded names. But these names don't actually overlap with each
[2:01:18] We're going to get stuck with a giant never as you can see. So instead, we just need to redefine this entire thing [[hard]]-coded, which is a little bit
[2:46:02] mistake in your code like this, it makes your code really [[hard]] to work with because now when you call this function, it's actually going to give you
[3:52:46] number and this value right here to just be a [[hard]]-coded string as you can see here. And for our assignment, let's go ahead and actually work on that. So, we

WORD: "harder"  —  1 hit
------------------------------------------------------------------------
[0:54] really the last Typescript course that you're ever going to need. We've even spent months animating some of the [[harder]] to understand parts so that if

WORD: "hardest"  —  1 hit
------------------------------------------------------------------------
[3:21:40] Okay. So if you've been zoning out you need to lock in and pay attention because this is by far the [[hardest]] thing to learn in Typescript but also one of

WORD: "difficult"  —  6 hits
------------------------------------------------------------------------
[13:37] [[difficult]] because you now need to fix the types across an entire massive project. So what they introduced is this
[1:45:10] third one, which is going to be age. So this is a little bit [[difficult]]. if we want to skip around with properties. While with objects, we can just get the
[3:02:36] do, but I would again recommend that pound symbol. It's sometimes a lot more [[difficult]] to use the pound symbol
[3:13:10] up, and it's very [[difficult]] to refactor. This is where the idea of utility types inside of TypeScript come along because
[3:55:01] unfortunately, when you get to this really high level of TypeScript knowledge in this TypeScript code, it starts to look and be very [[difficult]] to
[3:55:25] TypeScript writes it in such a different way than pretty much any programming language does. So, it's kind of [[difficult]] to read. And once you get used

WORD: "confusing"  —  10 hits
------------------------------------------------------------------------
[58:51] [[confusing]]. We're combining together a lot of different things. But when you get confused by a TypeScript type, I highly recommend breaking it down into
[1:21:56] really [[confusing]], but think about it. When you're accessing a dynamic property in JavaScript, you use the bracket
[1:42:05] something that is only too long. So that's a little bit [[confusing]] which is why they recommend that you use the readonly property when you're working
[2:18:44] JavaScript. And this is one of the big reasons I don't like enums because it's weird how that line gets blurred between the two and can be really [[confusing]]
[2:22:36] type for your enum inside of here, it actually has to convert that to JavaScript as well, which overall just makes things really [[confusing]]. So we're
[2:30:35] itself as we go through and along the if statement. It's super powerful what it can do. Now an often [[confusing]] type for
[2:52:43] find it way more [[confusing]] to work at because angle brackets in Typescript have a very specific meaning for generics. And overall, I've never seen
[3:25:11] [[confusing]] is you don't actually end up writing very many generics in your TypeScript code, especially if you're
[3:40:32] [[confusing]], especially when you have lots of nesting. So you can see here we're creating a brand new type that is checking some type to see if it extends
[3:50:25] bit [[confusing]] but luckily it reads kind of like English. So this K is our generic type that we're creating. This

WORD: "lost"  —  1 hit
------------------------------------------------------------------------
[19:07] you'd actually be casting it to a wider type and that more specific type information is now [[lost]]. To be fair,

WORD: "confused"  —  5 hits
------------------------------------------------------------------------
[58:51] confusing. We're combining together a lot of different things. But when you get [[confused]] by a TypeScript type, I highly recommend breaking it down into
[59:27] on top of the building blocks. So when you get [[confused]] by a type, try to break it down into those building blocks. It makes it much easier to parse. Now for
[3:16:32] Now, one thing that you may get slightly [[confused]] with is what I could do is I could remove this required type here and then I could just, you know, throw down
[3:58:45] can see that did successfully solve that problem. Now you may be a little bit [[confused]] by this key of T. Essentially we're just passing it in a union of
[4:23:01] beginner stuff all the way to some really, really advanced TypeScript stuff. So if you get [[confused]] when you're working on TypeScript in your

WORD: "stuck"  —  4 hits
------------------------------------------------------------------------
[2:01:18] We're going to get [[stuck]] with a giant never as you can see. So instead, we just need to redefine this entire thing hard-coded, which is a little bit
[3:25:29] I would recommend if you really get [[stuck]] with this section, just repeat this section of the video and it'll really help you understand what generics
[4:23:06] projects, feel free to come back to this video and check out the specific sections you get [[stuck]] on of generics or
[4:23:11] and so on. Wherever you get [[stuck]], come back, re-watch that section, and hopefully with your newfound knowledge and your trial and error, it'll help you

WORD: "can't"  —  39 hits
------------------------------------------------------------------------
[0:11] TypeScript course. My friendship with JavaScript has ended, and now TypeScript is my best friend. Look, you [[can't]] learn
[28:14] Typescript. You [[can't]] check to see if a variable is equal to this support type or anything like that inside of
[36:08] optional parameters must always come after your required parameters because you [[can't]] pass an optional parameter
[36:20] going to work. You can see we immediately get an error in Typescript saying that you [[can't]] have required parameters after optional parameters. So, just make sure if you have optional
[1:12:08] autocomplete on all the different properties in here that I need to define. And I [[can't]] redefine it because obviously it's specifically this male
[1:27:10] [[can't]] actually change what the value is. So if I just come in here I'll say that const a is going to have that type of
[1:28:23] means we [[can't]] change anything, but also makes it so that the actual definition of our type is specifically whatever we
[1:28:58] anything else. So obviously I [[can't]] push yellow into this. Also, if I try to access properties inside of here and I
[1:30:45] really nice because unlike object.freeze, not freeze. It actually makes it so I [[can't]] change the admins. I [[can't]] change the features. I [[can't]] add
[1:30:51] new features. I [[can't]] remove features. Everything all the way nested down to the lowest level possible is entirely immutable. Constant read only. [[Can't]]
[1:37:45] that we've created. So now when we call this function we either call it with this definition or we call it with this definition right here. But we [[can't]] do
[1:42:11] with tupils. So we mark this as read only. You're now going to see we get an error because we [[can't]] obviously push new values inside here. But the downside
[1:42:17] of making this readon is that we [[can't]] actually mutate it in any way which sometimes is what you want sometimes is
[1:42:34] ticket and we want to mark it as resolved. But you can see we [[can't]] modify this ticket. So instead we need to return a brand new version of this
[1:48:48] [[can't]] even tell you the last time that I used an optional tupil. But in specific use cases they do make sense to use. Now
[1:49:00] it [[can't]] be before a nonoptional property. Now luckily for us we just need to change ID to be required and we
[1:53:55] anything. It literally [[can't]] be any value at all. It [[can't]] be undefined. It [[can't]] be null. It [[can't]] have a value. It is literally nothing. And that may seem
[2:00:12] all the properties of human or you can have all the properties of elf, but you [[can't]] have any overlap. You [[can't]] have
[2:00:18] this ears property set if you're a human, for example, and you [[can't]] have this age property set if you're an elf. So let's go ahead and solve the code for
[2:04:11] with the type keyword because you [[can't]] augment the built-in window type with it, but you can merge into it using an
[2:12:12] say now it can only be a number for a wizard and also add some new properties. The only thing is you [[can't]] change the
[2:22:10] down, it's slightly simpler. And the only reason it's slightly simpler is because you [[can't]] actually convert from a string to the actual label for that.
[2:23:56] converts this directly to an object inside of JavaScript. So you can access the values from the labels but you [[can't]]
[2:24:25] you're definitely probably not going to be using const enums. Now if we look at the limitations of const enums, you can see here that reverse mapping you [[can't]]
[2:31:30] But if I try to do that on an unknown variable, I'm going to get an error because a is of type unknown. It [[can't]] do anything with it. Unknown does not
[2:32:25] what this thing is, so I [[can't]] give it a type, but I still want to use type checking inside my code. Now, let's get
[2:33:54] unfortunately, we [[can't]] just do the type of is equal to array because that's not an actual type. But we can use the
[2:39:37] sometimes you're using types from thirdparty libraries or other code that you [[can't]] change, which in case using this in keyword is really great. And
[2:48:19] when we get down here, we know that name is a string because if it's null or undefined, we already return. So TypeScript knows it [[can't]] be null or
[2:48:49] that if we got to that point, we are either null or undefined. So we know if we're past that point, we [[can't]] be null
[2:51:08] use a I [[can't]] access like two lowercase or anything like that because it is not a string. But I know for a fact that
[2:52:55] us to do inside of our assignment. We're using a thirdparty service for handling payments. And although they we [[can't]] have type safety on incoming data, we do
[3:00:10] [[can't]] access it out here. I'll get an error if I try to access it out here. And Typescript actually looks at this and it knows that this is private, and
[3:04:59] definition. Now something that is abstract for example an abstract class means you [[can't]] create a new shape. If
[3:05:05] we look down here we get an error. We [[can't]] create an instance of an abstract class. Essentially an abstract class is like a shell that we are saying hey we
[3:18:10] works properly. So this just allows us to essentially create a config where we [[can't]] change things like I [[can't]] come in here and change my API URL. It's going
[3:38:54] must be one of these three different flags. It [[can't]] be any other flag at all. It must be one of these three
[3:53:50] can return our result down here. Now we are getting an error because obviously here I [[can't]] define any specific values
[4:11:15] But a lot of libraries are written in JavaScript and just haven't been updated to TypeScript. So, you [[can't]] actually use any of the benefits because in

WORD: "cannot"  —  7 hits
------------------------------------------------------------------------
[34:17] well. So we can come down here and we know that since ID was a string up here that means that it [[cannot]] be a string
[1:16:07] arrays that [[cannot]] have duplicate values. So I can have an array of like 1 2 3. That's going to be fine as an
[1:27:33] to get an error because this is a readonly property, which means I [[cannot]] change the value. I can only read the value. This is not something you can
[1:28:53] and blue. And if we hover over this you can see it is a readonly array of red green blue. It literally [[cannot]] be
[1:53:49] something that you may think is completely useless because it's the opposite of any. It literally means this type can never happen. You [[cannot]] have
[1:59:49] into one brand new big type and the other one says you must be one of these different things. You [[cannot]] be more
[2:55:43] required. It [[cannot]] be null and it [[cannot]] be undefined. So, we look at the code here. We have this cleaned text

WORD: "couldn't"  —  1 hit
------------------------------------------------------------------------
[1:30:33] inside of JavaScript, it means I could not change my API URL. My admins, I [[couldn't]] redefine it, but I could add

WORD: "won't"  —  6 hits
------------------------------------------------------------------------
[1:54:30] Now, TypeScript [[won't]] give you an error. JavaScript [[won't]] give you an error. There's no notification that we did not handle this particular use case. But the
[2:08:29] [[won't]] run into the need for these performance issues as well. And as Typescript evolves, they make new performance changes. So it may be that
[2:41:34] Now, type predicates are quite advanced feature in Typescript that you mostly [[won't]] have to use, but in certain
[3:01:55] [[won't]] actually use a runtime error inside of JavaScript. So if I access this balance property in JavaScript, it
[3:02:01] [[won't]] throw an error. So it's important to notice the difference between these two different properties. And as I mentioned, we will be talking about this
[4:18:24] no error. That's essentially what this is trying to tell us. Now, if I use ignore, I [[won't]] get that handy message. So, this is really useful when maybe

WORD: "wouldn't"  —  1 hit
------------------------------------------------------------------------
[2:04:05] This is actually code that we use in production at bootdev to add the signin with Google feature. This [[wouldn't]] work

WORD: "don't get"  —  5 hits
------------------------------------------------------------------------
[10:41] and you [[don't get]] any errors in your code until you run it and then you get these errors. And most of the time, if you don't have a perfect test suite,
[1:31:03] here, I can change this admin's name and I can push new things into this array because those [[don't get]] frozen. It only
[1:36:27] definitely use cases where you need this. [[Don't get]] me wrong, I've written this before because certain situations need function overloads, but I would say
[1:56:18] I forgot to include this section, we [[don't get]] an error. But I can just come in here and I can say that this should satisfy never. And now it's going to
[2:27:43] with. It's consistent with everything else in Typescript and you [[don't get]] that weird extra TypeScript code or JavaScript code I should say added onto

WORD: "doesn't work"  —  5 hits
------------------------------------------------------------------------
[25:56] is we need to specify the variable name and the type of the variable. That's why this top one [[doesn't work]] because it doesn't have variable names. And this
[26:02] bottom one [[doesn't work]] because it doesn't have type information. Now, you may be realizing as we're going through this, certain things are quite long to
[1:30:27] least at the top level. So it [[doesn't work]] on nesting, but it works at the top level. For example, this config constant, if I actually freeze this
[4:16:08] different version. And if those versions are different, you could run into errors where your TypeScript compiler [[doesn't work]], but your editor is actually
[4:18:54] actually submit this. Let's go ahead and see if that works. And of course, it [[doesn't work]] because they specifically

WORD: "broken"  —  3 hits
------------------------------------------------------------------------
[8:44] users start sending you angry support emails telling you your site is [[broken]]. The creators of Typescript were
[18:14] actually returns this, you've potentially [[broken]] all the places where the function's called. Had you
[4:18:31] something is [[broken]] because like a library you're using is [[broken]], it needs to be updated. So, you can just throw an

WORD: "problem"  —  24 hits
------------------------------------------------------------------------
[8:39] mistake. Most likely, you'll deploy those types of bugs to production, and you'll only notice the [[problem]] when
[15:36] undefined, which is why we're getting tons of different errors. And in order to fix this particular [[problem]], we need to specifically type what these
[29:01] JavaScript by writing our import like this. But the [[problem]] with doing that is we're only importing type related information. So, we don't care about the
[34:57] parameter. So, if you want to take a function and only pass some of the parameters along, like I said, in JavaScript, you can do that no [[problem]].
[38:30] sure that this function always returns a number and it doesn't actually return undefined. And that should solve our [[problem]]. Now, often if you have an
[1:15:05] this internal address and this external address type to solve this [[problem]]. If we scroll down, you can see essentially create those different types for us. So
[1:24:22] make sure to double check and think, is this the best way that I can be solving this [[problem]] cuz often times it's probably not what you want to do because
[1:24:28] this can make your code much more complicated to work with. Now, if we look at trying to solve this particular [[problem]], we'll scroll all the way down
[1:41:04] Just like that. And now essentially I'm checking the lowercase version which should fix our [[problem]]. And now we have no errors. So now I want to show you why
[1:55:41] check for that. And that'll at least solve our [[problem]]. So we can say this will return our help message. And actually, if we run that right now,
[1:55:47] we've completely solved the [[problem]]. But I want to go a step further and show you that little trick that I talked about. So instead of redefining a variable to
[1:59:16] should hopefully solve everything. If I click submit, you can see it is now working successfully. So this is just a way to avoid that [[problem]] where you
[2:20:13] I'm going to be talking about at the end of this section, it actually covers this [[problem]] right here where you never run into this weird situation where you have
[2:32:31] rid of all that code from this example and go back through here. You can see the [[problem]] with any, as they say, is it allows you to do pretty much anything
[2:49:39] feedback rating is not valid or it is equal to null, well then we know that we have a [[problem]]. So we need to return
[2:51:25] string properties such as to lowercase on this particular string. Now, the [[problem]] with as is that if I'm wrong and
[2:54:18] [[problem]] because you're telling Typescript, okay, this ID, it's actually unknown. And since unknown is a broader type than number, it's okay with doing
[3:04:03] balance is accessible via the get balance method. So we have get balance that returns their balance. The [[problem]] though is our balance up here is
[3:12:46] property. So, they redefine everything in their user. There's a huge [[problem]] with this, especially as you get more
[3:58:45] can see that did successfully solve that [[problem]]. Now you may be a little bit confused by this key of T. Essentially we're just passing it in a union of
[4:08:55] that window support AI which we're defining inside of our legacy.js. But the [[problem]] is is that TypeScript
[4:11:04] of the biggest issues you run into, it used to be a bigger [[problem]], not as much anymore, but you install a library and
[4:13:21] [[problem]]. So, if we give these all a quick save, you'll notice everything inside of here is just an any type. It doesn't know what to do with any of
[4:16:44] enough, they have a note right here on restarting the TS server because it's a very common [[problem]]. If types aren't working like you expect, first thing you

WORD: "problems"  —  9 hits
------------------------------------------------------------------------
[22:28] And now after that change, your explicit return type is slightly different than your actual return type, which could lead to [[problems]] in your code, which is
[1:57:07] [[problems]]. For example, here we have Saiyan and we have human. And the name property on both of these is string. So
[2:22:24] with strings in the compiled code. But this is where a lot of people have [[problems]] with enums because now you're adding all this weird TypeScript code
[2:23:50] [[problems]] of enums in Typescript in that they don't actually add all that extra JavaScript code. Instead it essentially
[2:28:27] pro. And then down here we have the text of enterprise. And that should solve all of our different [[problems]]. I just have
[2:34:27] [[problems]]. I don't see any type errors. And if we submit, it looks like we actually do have an error. I took a quick look at the error message and that's because when we have an array,
[2:36:56] [[problems]]. Actually, it needs to be in this response, which has a meify message and a notify. So message is just that.
[2:50:17] There we go. And that should hopefully solve all of our [[problems]]. We can just click submit. And it looks like it is working fine. So again, this is just
[2:56:08] you're just telling Typescript, I know more than you. Just trust me on this one. And again, you run into all the same [[problems]] you do with as because

WORD: "issues"  —  3 hits
------------------------------------------------------------------------
[1:57:24] into [[issues]] where you don't have the same type. Name and name here may be completely different. And when you try to intersect them, you essentially get a
[2:08:29] won't run into the need for these performance [[issues]] as well. And as Typescript evolves, they make new performance changes. So it may be that
[4:11:04] of the biggest [[issues]] you run into, it used to be a bigger problem, not as much anymore, but you install a library and

WORD: "trouble"  —  1 hit
------------------------------------------------------------------------
[1:03:56] something that can be useful, can not be useful. can also be something you can easily get in [[trouble]] with by having an any type here. And generally I try to

WORD: "error"  —  120 hits
------------------------------------------------------------------------
[4:37] immediately give us an [[error]] because, as you can see, we're assigning a number to something that should be a string. So, this gives us a ton of different
[4:49] this [[error]] instead of having to run my code and waiting for that [[error]] to show up. So, to solve this lesson, it's really just a placeholder to kind of
[5:00] doesn't actually do anything at runtime. What that means is when you write your code like this, you can see I'm getting an [[error]] in my code because I'm
[6:24] mistype something in TypeScript it will give you an [[error]] which is really important. So here all we need to do is just change the type of this from a
[6:30] number to a string. There we go. And that should fix up that [[error]]. And now if we click submit, you can see everything is running properly. Now this
[12:50] And you can see immediately we get an [[error]]. TSC the TypeScript compiler. We're having an [[error]] that says type string is not assignable to type number
[16:34] when you do math on numbers, you still get a number. So everything is working fine. If I change this to a string, I'm going to get an [[error]] because it's
[32:35] access things such as two lowercase, you'll notice that I actually am going to get an [[error]]. And the [[error]] is
[32:47] two lowerase. So it's going to throw an [[error]] for me. So this is why this type narrowing is really important because it allows you to take something that is
[36:20] going to work. You can see we immediately get an [[error]] in Typescript saying that you can't have required parameters after optional parameters. So, just make sure if you have optional
[38:00] down here we know it's a string. And now we're checking our string based values. And if we submit, you notice we're technically getting an [[error]]. It's
[48:28] see we have [[error]] codes 1 or two or three and we're also saying or number. Now this essentially narrows down to
[48:34] just or number. Essentially if you wrote this as just [[error]] codes equals number that will be the exact same type. The
[52:57] colon followed by a string, and [[error]] colon followed by any string at all. And if I were to change this string to
[53:03] be a string or number, you can now see when I hover over this, we have warn or number, [[error]] or string, [[error]] or
[54:46] you have too many of them. Now, it's very unlikely that you will run into this [[error]] because you don't normally write code like this. And most of the
[56:38] radians.length just like that. And that's now going to divide by the length of my ratings. And if we submit that, we're actually getting an [[error]] down
[56:59] give us an [[error]]. So now when we submit, we have the successful solution. Now there's an alternative way that you can define arrays. I don't use this option
[1:01:30] essentially. Now, if we scroll all the way down to what we're supposed to be doing in this code, you can see that if we run this, we're going to be getting an [[error]]. Essentially, you can see here
[1:08:57] actually going to get an [[error]] because this weapons is not required. And this is just to help out you as a developer
[1:09:37] warning saying, "Hey, there's some type of [[error]] inside your code because you spelled speed incorrectly." It'll let you know that particular type of
[1:11:38] array. We can say a.name is equal to whatever. And you're going to see we get an [[error]] because it doesn't know, hey,
[1:14:03] you back some data and it's going to have three different states. You can have the loading state where there's no data and there's no [[error]]. It's just
[1:14:10] loading. We can have the success state where we get back a data property or we can have an [[error]] state where we get
[1:14:15] back an [[error]] object. So now we have three different distinct states that we can be in. So if we created that as an
[1:14:26] going to be the text loading. We can now copy this down. Let's say that we have an [[error]]. The status on this one is
[1:14:31] going to be [[error]]. And we know that we have some type of [[error]] value. It doesn't matter what it is. We can just say that it's going to be a number for
[1:14:43] now instead of having an [[error]] we have some data and this is going to be like a string with our [[error]] or our data message or whatever it is. So you can
[1:17:01] try to add a value that's a number, I'm going to get an [[error]]. But if I try to add a string, you can see that it works just fine. Now, this is again using that
[1:17:59] set.length just like that. And if we submit, we of course get an [[error]] because I always forget sets are slightly different than arrays. And
[1:21:36] example, true or false. Those don't throw errors, but as soon as I put like a number in here, I'm going to get an [[error]] unless I change this to number.
[1:27:33] to get an [[error]] because this is a readonly property, which means I cannot change the value. I can only read the value. This is not something you can
[1:29:03] try to access for example a property beyond the last property we have, I get an [[error]] because there's no not enough
[1:31:51] are getting an [[error]] for our as const. We don't actually need that anymore because it's kind of somewhat assumed with object.freeze is not as powerful
[1:33:53] a number, I'm now going to get an [[error]] because it no longer satisfies that property because this does not contain an age, and I would need to pass in an
[1:40:51] we submit, that should work. Looks like we actually have an [[error]]. And if we scroll down, the actual reason for that [[error]] is because this should be a not or
[1:41:34] [[error]] because there's not more than three things. It knows there's exactly three things with those exact types. This is something that a lot of function
[1:42:11] with tupils. So we mark this as read only. You're now going to see we get an [[error]] because we can't obviously push new values inside here. But the downside
[1:43:00] notice we actually run into a massive pitfall, which is one of the biggest things you run into. As you look at this [[error]], it says our type is string or
[1:48:19] response. It requires a status code, a data, and this [[error]] is optional by adding that question mark. So you can
[1:54:18] sure we handle all three of those. And if we pass in something that's not one of those three, we can throw an [[error]] to the user to let them know, hey, for some
[1:54:24] reason something bad got passed into this function. You'll notice an [[error]]. We didn't actually pass in the code 500.
[1:54:30] Now, TypeScript won't give you an [[error]]. JavaScript won't give you an [[error]]. There's no notification that we did not handle this particular use case. But the
[1:54:36] never type can actually help us with that. If we scroll down here a little bit further, you can see right here, we're taking this [[error]] and we're
[1:54:42] setting the type to never and we're setting it equal to our code. So now you can see it's giving us an [[error]] in Typescript saying type 500 is not
[1:55:02] those specific use cases. So this will give us an [[error]] if we forget to check one of those use cases. And now if we
[1:55:07] check it, you can see we have no [[error]] because code at this point is always going to be a never type. So we just need to essentially implement that. And
[1:55:30] the command is greet, we do greet. If the command is info, we do info. And of course, here we have that [[error]]. Type help is not assignable the type number
[1:55:53] never like this, we can actually use the satisfies keyword and throw an [[error]] here instead. Now this is returning an
[1:55:59] [[error]]. But in our case, let's say that we wanted to throw an [[error]]. We could say we wanted to throw a new [[error]] just like this. And we could say unexpected.
[1:56:12] And we can specify what the command is just like this. So now at least it's throwing an [[error]], but we no longer have that type checking. So, for example, if
[1:56:18] I forgot to include this section, we don't get an [[error]]. But I can just come in here and I can say that this should satisfy never. And now it's going to
[1:56:25] give us an [[error]] if this doesn't satisfy never. Right now it does cuz we're checking everything. But as soon as we forget to check one, boom, I get an
[1:56:31] [[error]] right here because this does not satisfy the never type. This makes it so I don't have to create a brand new variable. And it makes it so it doesn't
[1:56:43] works. If I submit, everything is fine. But if I come up here and I, you know what, say I'm actually going to add a new one in here for [[error]]. Now, if I
[2:02:50] exact same name, TypeScript will actually throw an [[error]] saying you've already defined that type. And that's
[2:11:41] with no parameters that returns a string. So we can just come in here with a string just like that. Now I just got to fix my type [[error]]. I just don't have
[2:12:17] type to be something that's not allowed. So here the rank can only be a string and here I'm trying to change it to a number. That's going to throw an [[error]]
[2:12:29] system. So this is with types this would turn into a never while with interfaces it just throws us an [[error]]. So let's go
[2:12:40] take that system event and create some more specific versions like an [[error]] event, an outage event and so on. So
[2:12:45] let's create this first interface of [[error]] event. We can just come down here. We'll say that we're going to export an
[2:12:51] interface that is an [[error]] event. And this [[error]] event first of all needs
[2:13:02] types for it. So in our case the type is [[error]]. We know that the payload
[2:14:31] is declaration merging. If you create the same interface multiple different times, instead of throwing you an [[error]]
[2:14:54] three of these together, just like we have down here. Now, if we did this with a type, we would get an [[error]] because we're essentially trying to redefine a
[2:15:06] an [[error]]. This is generally what I want. If I define one type and I redefine that type somewhere else, I want to get an
[2:15:12] [[error]] saying I shouldn't be redefining that. I don't want them to merge together cuz that's going to most likely cause different bugs for me. Now, there
[2:19:52] code here. So we're able to print out like [[error]] messages and so on with these different login information from our
[2:21:30] should solve our case. And if we click submit, looks like we actually have an [[error]]. And that's because I again forgot to read all the instructions. If the
[2:21:36] severity number doesn't match, we're going to throw an [[error]]. So our default case should throw an [[error]]. So we'll say
[2:21:42] throw new [[error]]. And this [[error]] should say unknown severity. So we'll just paste that in there. And now if we
[2:22:42] just going to kind of play around with that reverse mapping for our assignment. I want to create a new function called get [[error]] label. So we'll say export
[2:22:48] function get [[error]] label. It should take in an [[error]] code which is an internal [[error]]. There we go.
[2:23:01] to get the actual [[error]] name and return a string in the format code followed by name with code name actually replaced with those specific values and if the
[2:23:08] [[error]] code is not a value we return unknown [[error]]. So we can just say here that we want to get the value which is going to be equal to internal errors and
[2:23:15] we're going to pass in our [[error]] code just like that. And then if our value is
[2:23:20] equal to null for example the value doesn't exist then we can return that string which is unknown [[error]]. So I'm
[2:23:32] can say return what is it? our [[error]] code followed by a
[2:29:49] a limit. And we need to look at the open ticket function and notice that it current state produces a compiler [[error]]. So you can see here customer.above above
[2:29:55] limit is throwing a particular [[error]] for us. We just want to fix that bug using type limiting. So here we have a regular
[2:31:30] But if I try to do that on an unknown variable, I'm going to get an [[error]] because a is of type unknown. It can't do anything with it. Unknown does not
[2:34:10] that [[error]]. Now, we can come down here. Otherwise, source should be the string unknown. The content should be an empty string. So, we can just say at the very
[2:34:27] problems. I don't see any type errors. And if we submit, it looks like we actually do have an [[error]]. I took a quick look at the [[error]] message and that's because when we have an array,
[2:35:17] like [[error]] checking and stuff that we talked about earlier. And this is the narrowest you can possibly get. You've essentially narrowed down your type to
[2:38:21] our type more and more throughout doing all of this different code. Now if we give that a submit, we are getting an [[error]]. That's just cuz I forgot to put a
[2:46:20] they do exactly what you expect. Because if you have an [[error]] in this function, it can propagate throughout your entire application, ruining your type safety.
[2:46:51] Typescript. And we kind of looked at this where we were using like throw [[error]] as the default case and we're using that satisfies never to give us
[2:46:58] that particular [[error]] checking. So this is just kind of recovering the stuff that we've already talked about a little bit. And if we go down to this
[2:47:03] assignment, it says the increment count function is working as intended, but someone committed an unnecessary default case that throws an [[error]]. So we look at
[2:47:15] complaint, upgrade, or refund. And we're checking all four of those right here. And then we have this [[error]] down here which is actually giving us an [[error]]
[2:47:32] just come in here with a default case and that's where I would put my [[error]] because this allows me to always make sure that I actually get an [[error]] inside
[2:47:45] And now if I add a brand new topic up here, for example, doesn't matter what it is, I'll get an [[error]] down here saying I still need to implement that
[2:48:42] thing with guard clauses is also if we throw an [[error]] instead, it still narrows our type. So it doesn't matter if we return or throw an [[error]], it'll know
[2:51:31] actually a is a number at this point, it's going to throw an [[error]] in my code when I run it, but TypeScript will not
[2:51:36] give me an [[error]]. So, it's a potential source of errors, which is why I generally try not to use as very often.
[2:54:00] number and it can never be a string. So, we're going to throw an [[error]]." But if you want to get around this for some reason, you may have a use case for
[3:00:10] can't access it out here. I'll get an [[error]] if I try to access it out here. And Typescript actually looks at this and it knows that this is private, and
[3:00:16] it'll give us a proper type [[error]] anytime we try to access a private property from outside of the class that
[3:01:55] won't actually use a runtime [[error]] inside of JavaScript. So if I access this balance property in JavaScript, it
[3:02:01] won't throw an [[error]]. So it's important to notice the difference between these two different properties. And as I mentioned, we will be talking about this
[3:04:30] its errors. Let's check to see if we have anything else. Fix the [[error]] by updating that. Yep. So that's all correct. So now we should be able to
[3:05:05] we look down here we get an [[error]]. We can't create an instance of an abstract class. Essentially an abstract class is like a shell that we are saying hey we
[3:18:17] to throw an [[error]] because it is read only. Now, I briefly talked about the record utility type when it came to defining objects with dynamic keys. And
[3:19:00] passing along my key for healer. So, it's going to give me a TypeScript [[error]] because it's missing that particular role capacity inside of our player role
[3:27:37] array. Now let's make sure that works before I start explaining exactly what's going on. Now we do have a quick [[error]]. I need to put an and here instead of an
[3:34:58] That's relatively straightforward. Now I do believe we have a small [[error]]. If I hover down here, you can see job.shift technically could return undefined. So
[3:35:05] this could be element or undefined. And that should fix those errors in Typescript. And if we submit, looks like we do still have an [[error]] though. And
[3:48:09] function could take any type. Return that first parameter type. Now, I'm going to submit this. And we are getting an [[error]]. Of course, it's because I
[3:49:20] And that's just going to be equal to passing that a generic along here. That should still work successfully. And when I submit, we are getting an [[error]]
[3:51:30] can pass along. As soon as I pass along something else, I get an [[error]] because it's not one of those three different values. So key of just gets the keys of
[3:53:50] can return our result down here. Now we are getting an [[error]] because obviously here I can't define any specific values
[4:17:48] realizing there's an [[error]], and then ignoring that [[error]]. So what we can do inside of our code, we have that global.t.ts file. Let's just completely
[4:17:54] delete that. Now we get an [[error]] right here, and we can just come in here with that check. So we can say at ts ignore,
[4:18:06] recommend using the ts expect [[error]]. It does the exact same thing as ignore. If there is an [[error]] on the next line,
[4:18:11] it'll say, "Hey, there's an [[error]]. I'm going to completely ignore it." But if there's no [[error]] after this, it'll actually throw an [[error]] on itself. So,
[4:18:18] for example, if I put that up here, you'll notice it says there's an [[error]]. Hey, I expected there to be use an [[error]] after this particular line, but there is
[4:18:24] no [[error]]. That's essentially what this is trying to tell us. Now, if I use ignore, I won't get that handy message. So, this is really useful when maybe
[4:18:36] expect [[error]] on here and then when that library finally gets updated, you'll notice that this thing has been updated. So, you then can remove this expect
[4:18:43] [[error]] because it'll essentially tell you, hey, there's no longer an [[error]] on this line. So, I almost always use expect [[error]] over ignore, but they both
[4:23:11] and so on. Wherever you get stuck, come back, re-watch that section, and hopefully with your newfound knowledge and your trial and [[error]], it'll help you

WORD: "errors"  —  59 hits
------------------------------------------------------------------------
[4:43] information on the types inside of our code. It gives us [[errors]] if things are wrong and it makes writing our code easier because now I can immediately see
[10:08] related [[errors]]. That's like the basic thing most people think of when they think of TypeScript. But that is in my opinion the least important of all the
[10:30] variable as a parameter. To change that in TypeScript is easy. You change it in one place and it'll give you [[errors]]
[10:41] and you don't get any [[errors]] in your code until you run it and then you get these [[errors]]. And most of the time, if you don't have a perfect test suite,
[10:48] which nobody does, these [[errors]] are going to make it into production. Then you're going to get angry emails from users, and that's definitely not what
[12:45] TypeScript and have it work just fine. Now to show you what these types of [[errors]] looks like, I'm going to come in here. So I'm going to click on submit.
[13:59] you do with this variable, it will not throw any [[errors]] and it'll work just fine. So for example, here I have this system prompt which we have specifically
[14:16] get any [[errors]] because essentially TypeScript says this could be anything. So it maybe has a function with this name. I don't know. Now I personally
[15:36] undefined, which is why we're getting tons of different [[errors]]. And in order to fix this particular problem, we need to specifically type what these
[16:22] I just come in here and I specify number, you can now see all the different [[errors]] inside of here have been completely removed because I've
[21:16] prompt. Just like that. And if we just close that off, you'll notice we're actually not getting any [[errors]] even
[54:40] types. Because if you get too many of these types that become too large, not only will it slow down your TypeScript, but you could run into these [[errors]] if
[1:10:00] can essentially just copy two, change that to CC. That should fix all our [[errors]]. And if we submit, you can see it's working properly. Now, just like we
[1:12:42] [[errors]]. If we scroll down, I don't see any [[errors]]. So, let's go ahead and submit this. And you can see we have no [[errors]]. It's working fine. Now, a
[1:15:36] Make sure I spell all this properly. And if we scroll down, we should see that cleans up all of our different [[errors]], at least in this case. But it's actually
[1:15:42] not quite cleaning up all of our [[errors]] cuz we don't have a type for external address yet. So I'm going to copy over what we have here. Paste that down.
[1:16:00] scroll down we have no more [[errors]] and if we submit everything will work fine. Now inside of JavaScript we have a concept called sets. Sets are like fancy
[1:21:36] example, true or false. Those don't throw [[errors]], but as soon as I put like a number in here, I'm going to get an error unless I change this to number.
[1:24:33] here to our assignment. Essentially, we want to run the code to see what the [[errors]] are. bunch of different [[errors]] about stuff and we just want to fix it to make sure everything's working. In
[1:31:25] assignment. So we're going to run the code and we're going to get some compile time and immutability [[errors]]. If I run, you can see some things are passing, but
[1:36:38] overhead into your code. So, let's take a quick look at what our code is looking like. And we can see that it's going to have some [[errors]] that we need to fix.
[1:41:04] Just like that. And now essentially I'm checking the lowercase version which should fix our problem. And now we have no [[errors]]. So now I want to show you why
[1:41:58] we paste that in, you'll see we get no [[errors]] at all. this name and age now just has this brand new property added onto it even though it's defined as
[1:48:54] in our case we just need to kind of fix the different [[errors]] and fix the function that's working with this. The first thing is is our ID is optional but
[1:52:49] top of it. So we can come in here and define all the different types we want. Now I'm getting into some [[errors]] because I need to obviously type this as a type.
[1:55:19] for this project. We just need to run the code. We're going to have some [[errors]] and then we need to fix the code to fix those [[errors]]. So let's just take
[1:56:49] scroll down, I immediately get [[errors]] to notify me that I need to update my code to handle that brand new command that I just created, which is why this type of
[2:11:47] a colon here. That fixes all the different [[errors]]. And if I submit, it looks like it's working just fine. So this just shows you you can extend
[2:14:13] Now if I submit that we're getting some [[errors]] and that's because I did a typo. This should be duration in seconds not
[2:14:19] duration. Now if I submit you can see that solved all of our [[errors]]. So reading the instructions definitely useful. Now, this is the feature of
[2:22:55] and it needs to return a string but we can just do that automatically with TypeScript's inference. Then it should use reverse mapping on the [[errors]] enum
[2:23:08] error code is not a value we return unknown error. So we can just say here that we want to get the value which is going to be equal to internal [[errors]] and
[2:33:42] should clean up all those different [[errors]]. Then I come down here and do essentially the exact same thing. If the input is an array, then the source
[2:34:27] problems. I don't see any type [[errors]]. And if we submit, it looks like we actually do have an error. I took a quick look at the error message and that's because when we have an array,
[2:36:41] disssatisfied here. And that should be handle negative sentiment. And that should get rid of all of our [[errors]] that
[2:41:28] submit. And of course, it should say attached file instead of attached document. Again, more copy paste [[errors]]. And now when we submit, it's working.
[2:46:45] all checked by these three. So, this is unreachable code. So we want to make sure that we actually get [[errors]] when we specifically reach this type of code in
[2:47:51] topic. While if I have everything implemented, I no longer get any [[errors]]. And if I submit, you can see our code is working. Now, guard clauses are
[2:51:36] give me an error. So, it's a potential source of [[errors]], which is why I generally try not to use as very often.
[2:55:19] assertion to incorrect types causing runtime [[errors]]. That sounds correct, because it's rude and because it results in slow compilation. So yeah, it's
[2:56:14] maybe this is actually null and you didn't actually check it. You just told Typescript it's not and now you're going to run into runtime [[errors]]. So, I would
[3:01:02] this we are getting some [[errors]]. That's because I forgot to put that hashtag symbol at the start of balance up here inside of our constructor. Now if I run
[3:01:26] our code is still going to work. You can see we have no [[errors]]. If I submit it, it is going to give us [[errors]] because it expects certain things to actually work
[3:01:44] this pound symbol, this is actually interpreted by JavaScript. So JavaScript will throw [[errors]] during the runtime if
[3:04:30] its [[errors]]. Let's check to see if we have anything else. Fix the error by updating that. Yep. So that's all correct. So now we should be able to
[3:06:50] spell that properly and I make sure that there's no [[errors]] and we submit, we should see everything works just fine. Now, if you've worked with other
[3:35:05] this could be element or undefined. And that should fix those [[errors]] in Typescript. And if we submit, looks like we do still have an error though. And
[3:49:51] if we run that we are still getting some [[errors]] and I believe that's because the way parameters work is it doesn't actually return undefined. You can see
[4:04:48] really old JavaScript project to TypeScript, maybe then it doesn't make sense cuz you're going to have so many [[errors]] immediately. But strict, if
[4:06:06] plate in your code, but can help you fix some runtime [[errors]] where you actually don't have an element in your array when you try to access it. So, what we need
[4:06:24] the most important being that strict of true. And now immediately we're getting some [[errors]]. You can see here I need to actually specify a type for my name
[4:09:56] thing. You'll notice our TypeScript [[errors]] still aren't fixed. Often times to make this work, you just need to export an empty object and that'll
[4:10:02] actually fix everything. So that just tells Typescript, hey, take a look at this file. It exists. And now you can see that fixed our [[errors]] and we have
[4:15:03] server. So if you run into weird bugs where you expect your code to be working but there are [[errors]]. Restarting your TypeScript server will almost always fix
[4:16:02] showing you [[errors]], that editor is actually using its own version of TypeScript. It may be trying to use the same version or it may be using a
[4:16:08] different version. And if those versions are different, you could run into [[errors]] where your TypeScript compiler doesn't work, but your editor is actually
[4:16:14] showing no [[errors]] or your editor is showing [[errors]] even though your TypeScript compiler is working just fine. So it's really important that you
[4:17:21] throw [[errors]] and you don't want to spend the time to actually fix those [[errors]]. So, you can use the at TS ignore line,
[4:17:37] a TypeScript project cuz you have lots of [[errors]] that you'll need to fix. So turning some of them off could be really useful. So what we're going to do is

WORD: "fail"  —  1 hit
------------------------------------------------------------------------
[4:06:36] we can give that a quick save. Let's read the rest of this. You can see we can try to power code. It'll [[fail]]. But we already fixed that. Change the main

WORD: "failed"  —  1 hit
------------------------------------------------------------------------
[2:45:29] incorrectly. Either I [[failed]] to do all my proper checks inside of here. Or maybe I accidentally returned the wrong

WORD: "failing"  —  1 hit
------------------------------------------------------------------------
[1:34:30] inside of our assignment. We need to run the code as is to see the [[failing]] satisfies check. So this is actually [[failing]]. We can even just see that bush
